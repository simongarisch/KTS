{"version":"1","records":[{"hierarchy":{"lvl1":"Intro"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Intro"},"content":"Kotlin is a modern, statically typed programming language developed by JetBrains (the creators of IntelliJ IDEA) and runs on the Java Virtual Machine (JVM).\n\nprintln(\"hello, world\")\n\nvar meaningOfLife = 42\nprintln(meaningOfLife)\n\nfun main(args: Array<String>) {\n    if (args.size > 0) {\n        println(args)\n    }\n    println(\"hello, world\")\n}\n\nval args = emptyArray<String>()\nmain(args)\n\n... all fairly straightforward ...\n\n","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Intro","lvl2":"FizzBuzz"},"type":"lvl2","url":"/#fizzbuzz","position":2},{"hierarchy":{"lvl1":"Intro","lvl2":"FizzBuzz"},"content":"\n\nfun Int.isDiv(vararg ints: Int): Boolean {\n    for (i in ints) {\n        if (this % i != 0) {\n            return false\n        }\n    }\n    return true\n}\n\n3.isDiv(2)\n\n6.isDiv(2)\n\nfun fizzBuzz(n: Int): String {\n    if (n.isDiv(3, 5)) {\n        return \"FizzBuzz\"\n    } else if (n.isDiv(3)) {\n        return \"Fizz\"\n    } else if (n.isDiv(5)) {\n        return \"Buzz\"\n    }\n\n    return n.toString()\n}\n\nfor (n in 1..20) {\n    println(fizzBuzz(n))\n}\n\nAlternatively...\n\nThe when expression serves as an expressive alternative to the switch.\n\nfun fizzBuzz2(n: Int): String {\n    when {\n        n.isDiv(3, 5) -> return \"FizzBuzz\"\n        n.isDiv(3) -> return \"Fizz\"\n        n.isDiv(5) -> return \"Buzz\"\n        else -> return n.toString()\n    }\n}\n\nfor (n in 1..20) {\n    println(fizzBuzz2(n))\n}\n\n","type":"content","url":"/#fizzbuzz","position":3},{"hierarchy":{"lvl1":"Loopy"},"type":"lvl1","url":"/loopy","position":0},{"hierarchy":{"lvl1":"Loopy"},"content":"","type":"content","url":"/loopy","position":1},{"hierarchy":{"lvl1":"Loopy","lvl2":"Through a range"},"type":"lvl2","url":"/loopy#through-a-range","position":2},{"hierarchy":{"lvl1":"Loopy","lvl2":"Through a range"},"content":"\n\nfor (i in 1..4) {\n    print(\"$i | \")\n}\n\nfor (i in 1..<4) {\n    print(\"$i | \")\n}\n\n","type":"content","url":"/loopy#through-a-range","position":3},{"hierarchy":{"lvl1":"Loopy","lvl2":"Iterating through an array"},"type":"lvl2","url":"/loopy#iterating-through-an-array","position":4},{"hierarchy":{"lvl1":"Loopy","lvl2":"Iterating through an array"},"content":"\n\nval colors = arrayOf(\"red\", \"green\", \"blue\")\nfor (color in colors) {\n    print(\"$color | \")\n}\n\n","type":"content","url":"/loopy#iterating-through-an-array","position":5},{"hierarchy":{"lvl1":"Loopy","lvl2":"Iterating through a list"},"type":"lvl2","url":"/loopy#iterating-through-a-list","position":6},{"hierarchy":{"lvl1":"Loopy","lvl2":"Iterating through a list"},"content":"\n\nval numbers = listOf(\"one\", \"two\", \"three\")\nfor (number in numbers) {\n    print(\"$number | \")\n}\n\n","type":"content","url":"/loopy#iterating-through-a-list","position":7},{"hierarchy":{"lvl1":"Loopy","lvl2":"With index"},"type":"lvl2","url":"/loopy#with-index","position":8},{"hierarchy":{"lvl1":"Loopy","lvl2":"With index"},"content":"\n\nfor ((index, item) in numbers.withIndex()) {\n    print(\"$index:$item | \")\n}\n\n","type":"content","url":"/loopy#with-index","position":9},{"hierarchy":{"lvl1":"Loopy","lvl2":"Iterators"},"type":"lvl2","url":"/loopy#iterators","position":10},{"hierarchy":{"lvl1":"Loopy","lvl2":"Iterators"},"content":"\n\nval numbers = listOf(\"one\", \"two\", \"three\", \"four\")\nval numbersIterator = numbers.iterator()\n\nwhile (numbersIterator.hasNext()) {\n    print(\"${numbersIterator.next()} | \")\n}\n\n","type":"content","url":"/loopy#iterators","position":11},{"hierarchy":{"lvl1":"Loopy","lvl2":"For each"},"type":"lvl2","url":"/loopy#for-each","position":12},{"hierarchy":{"lvl1":"Loopy","lvl2":"For each"},"content":"\n\nval numbers = listOf(1, 2, 3, 4, 5)\nnumbers.forEach { number ->\n    print(\"$number | \")\n}\n\n","type":"content","url":"/loopy#for-each","position":13},{"hierarchy":{"lvl1":"Loopy","lvl2":"For each indexed"},"type":"lvl2","url":"/loopy#for-each-indexed","position":14},{"hierarchy":{"lvl1":"Loopy","lvl2":"For each indexed"},"content":"\n\nval numbers = listOf(1, 2, 3, 4, 5)\nnumbers.forEachIndexed { index, number ->\n    print(\"$index:$number | \")\n}\n\n","type":"content","url":"/loopy#for-each-indexed","position":15},{"hierarchy":{"lvl1":"Loopy","lvl2":"While"},"type":"lvl2","url":"/loopy#while","position":16},{"hierarchy":{"lvl1":"Loopy","lvl2":"While"},"content":"\n\nvar x = 10\nwhile (x >= 0) {\n    print(\"$x | \")\n    x--\n} \n\n","type":"content","url":"/loopy#while","position":17},{"hierarchy":{"lvl1":"Loopy","lvl2":"Funky"},"type":"lvl2","url":"/loopy#funky","position":18},{"hierarchy":{"lvl1":"Loopy","lvl2":"Funky"},"content":"\n\nval numbers = (0..9).toList()\nval result = numbers\n    .map { it + 1 }         // now 1 -> 10 \n    .filter { it % 2 == 0 } // get even only\n    .reduce { accumulator, element -> accumulator + element } // sum\nresult\n\n","type":"content","url":"/loopy#funky","position":19},{"hierarchy":{"lvl1":"Numbers"},"type":"lvl1","url":"/numbers","position":0},{"hierarchy":{"lvl1":"Numbers"},"content":"val one = 1 // Int\nval threeBillion = 3000000000 // Long\nval oneLong = 1L // Long\nval oneByte: Byte = 1\n\nprintln(\"${one} is of type ${one::class.simpleName}\")\n\nprintln(\"${threeBillion} is of type ${threeBillion::class.simpleName}\")\n\nprintln(\"${oneLong} is of type ${oneLong::class.simpleName}\")\n\nprintln(\"${oneByte} is of type ${oneByte::class.simpleName}\")\n\n","type":"content","url":"/numbers","position":1},{"hierarchy":{"lvl1":"Numbers","lvl2":"Number collections"},"type":"lvl2","url":"/numbers#number-collections","position":2},{"hierarchy":{"lvl1":"Numbers","lvl2":"Number collections"},"content":"The major difference between Array and List is that Arrays have a fixed size while (Mutable)List can adjust their size dynamically. Moreover Array is mutable whereas List is not.\n\n","type":"content","url":"/numbers#number-collections","position":3},{"hierarchy":{"lvl1":"Numbers","lvl3":"Array","lvl2":"Number collections"},"type":"lvl3","url":"/numbers#array","position":4},{"hierarchy":{"lvl1":"Numbers","lvl3":"Array","lvl2":"Number collections"},"content":"\n\nval a1 = arrayOf(1, 2, 3)\na1\n\na1[0] = 0\na1[a1.size-1] = -3\na1\n\nval ints = arrayOf<Int>(1, 2, 3, 4, 5) // type explicit\nints\n\nval ns = arrayOf<Long>(4, 3, 2, 1)\nns\n\nns.size\n\nns.sum()\n\nns.sort()\nns\n\n","type":"content","url":"/numbers#array","position":5},{"hierarchy":{"lvl1":"Numbers","lvl3":"List","lvl2":"Number collections"},"type":"lvl3","url":"/numbers#list","position":6},{"hierarchy":{"lvl1":"Numbers","lvl3":"List","lvl2":"Number collections"},"content":"\n\nval l1 = listOf(1, 2, 3)\nl1\n\nl1::class\n\nval l2 = mutableListOf(1, 2, 3)\nl2\n\nl2::class\n\nl2[0]\n\nl2[l1.size-1]\n\nl2[0] = 7 // this is mutable\nl2\n\nl2.add(9)\n\nl2\n\n// l1[0] = 7 // can't do this...\n\n","type":"content","url":"/numbers#list","position":7},{"hierarchy":{"lvl1":"Numbers","lvl3":"map","lvl2":"Number collections"},"type":"lvl3","url":"/numbers#map","position":8},{"hierarchy":{"lvl1":"Numbers","lvl3":"map","lvl2":"Number collections"},"content":"\n\nval d1 = mapOf(\"a\" to 1, \"b\" to 2, \"c\" to 3)\nd1\n\nd1::class\n\nval d2 = mutableMapOf(\"d\" to 4, \"e\" to 5, \"f\" to 6)\nd2\n\nd1::class\n\n","type":"content","url":"/numbers#map","position":9},{"hierarchy":{"lvl1":"Numbers","lvl2":"Number functions"},"type":"lvl2","url":"/numbers#number-functions","position":10},{"hierarchy":{"lvl1":"Numbers","lvl2":"Number functions"},"content":"\n\nfun add(a: Int, b: Int): Int {\n    return a + b\n}\n\nadd(1, 2)\n\nfun add(vararg ns: Int): Int {\n    var total: Int = 0\n    for (n in ns) {\n        total += n\n    }\n    return total\n}\n\nadd(1, 2, 3, 4)\n\nval sum = {x: Int, y: Int -> x + y }\n\nsum(1, 2)\n\n","type":"content","url":"/numbers#number-functions","position":11},{"hierarchy":{"lvl1":"Numbers","lvl2":"bigint"},"type":"lvl2","url":"/numbers#bigint","position":12},{"hierarchy":{"lvl1":"Numbers","lvl2":"bigint"},"content":"\n\nimport java.math.BigInteger\n\nval bigIntOne = BigInteger(\"123456789012345678901234567890\") // from String\nval bigIntTwo = BigInteger.valueOf(100L) // from Long\nval bigIntZero = BigInteger.ZERO // Predefined constant for zero\n\nval sum = bigIntOne + bigIntTwo // Instead of bigIntOne.add(bigIntTwo)\nval difference = bigIntOne - bigIntTwo // Instead of bigIntOne.subtract(bigIntTwo)\nval product = bigIntOne * bigIntTwo // Instead of bigIntOne.multiply(bigIntTwo)\nval quotient = bigIntOne / bigIntTwo // Instead of bigIntOne.divide(bigIntTwo)\n\nsum\n\ndifference\n\nproduct\n\nquotient\n\n","type":"content","url":"/numbers#bigint","position":13},{"hierarchy":{"lvl1":"Numbers","lvl2":"Extensions"},"type":"lvl2","url":"/numbers#extensions","position":14},{"hierarchy":{"lvl1":"Numbers","lvl2":"Extensions"},"content":"Kotlin allows extension functions and extension properties that allow adding new functionality to existing classes.\n\nfun Int.double(): Int {\n    return this * 2\n}\n\n2.double()\n\nfun Int.isDivBy(vararg ns: Int): Boolean {\n    for (n in ns) {\n        if (this % n != 0) {\n            return false\n        }\n    }\n    return true\n}\n\n10.isDivBy(7, 11)\n\n10.isDivBy(2, 5, 10)\n\n","type":"content","url":"/numbers#extensions","position":15}]}